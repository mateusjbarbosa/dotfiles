import{fileURLToPath}from"url";import{extname}from"path";import{readFileSync}from"fs";import arg from"arg";function getTracer(){return global.$_$tracer}import{getFormat,transformSource,resolve as resolveImplmentation}from"./hooks.mjs";const extensionFormatMap={__proto__:null,".cjs":"commonjs",".js":"module",".mjs":"module",".json":"json"},legacyExtensionFormatMap={__proto__:null,".cjs":"commonjs",".js":"commonjs",".json":"commonjs",".mjs":"module",".node":"commonjs"};function getOptionValue(e){return parseOptions(),options[e]}let options;function parseOptions(){options||(options={"--preserve-symlinks":!1,"--preserve-symlinks-main":!1,"--input-type":void 0,"--experimental-specifier-resolution":"explicit","--experimental-policy":void 0,"--conditions":[],"--pending-deprecation":!1,...parseArgv(getNodeOptionsEnvArgv()),...parseArgv(process.execArgv),...getOptionValuesFromOtherEnvVars()})}function parseArgv(e){return arg({"--preserve-symlinks":Boolean,"--preserve-symlinks-main":Boolean,"--input-type":String,"--experimental-specifier-resolution":String,"--es-module-specifier-resolution":"--experimental-specifier-resolution","--experimental-policy":String,"--conditions":[String],"--pending-deprecation":Boolean,"--experimental-json-modules":Boolean,"--experimental-wasm-modules":Boolean},{argv:e,permissive:!0})}function getNodeOptionsEnvArgv(){const e=[];return ParseNodeOptionsEnvVar(process.env.NODE_OPTIONS||"",e)}function ParseNodeOptionsEnvVar(e,o){const n=[];let t=!1,r=!0;for(let i=0;i<e.length;++i){let a=e[i];if("\\"===a&&t){if(i+1===e.length)return o.push("invalid value for NODE_OPTIONS (invalid escape)\n"),n;a=e[++i]}else{if(" "===a&&!t){r=!0;continue}if('"'===a){t=!t;continue}}r?(n.push(a),r=!1):n[n.length-1]+=a}return t&&o.push("invalid value for NODE_OPTIONS (unterminated string)\n"),n}function getOptionValuesFromOtherEnvVars(){const e={};return"1"===process.env.NODE_PENDING_DEPRECATION&&(e["--pending-deprecation"]=!0),e}const experimentalSpeciferResolution=getOptionValue("--experimental-specifier-resolution"),experimentalJsonModules=getOptionValue("--experimental-json-modules"),experimentalWasmModules=getOptionValue("--experimental-wasm-modules"),packageJSONCache=new Map;function getPackageConfig(e){const o=packageJSONCache.get(e);if(void 0!==o)return o;let n,t;try{n=readFileSync(e,"utf8")}catch(e){}if(void 0===n){const o={pjsonPath:e,exists:!1,main:void 0,name:void 0,type:"none",exports:void 0,imports:void 0};return packageJSONCache.set(e,o),o}try{t=JSON.parse(n)}catch(e){throw new Error("Unexpected result: "+n+e.toString())}let{imports:r,main:i,name:a,type:s}=t;const{exports:l}=t;"object"==typeof r&&null!==r||(r=void 0),"string"!=typeof i&&(i=void 0),"string"!=typeof a&&(a=void 0),"module"!==s&&"commonjs"!==s&&(s="none");const p={pjsonPath:e,exists:!0,main:i,name:a,type:s,exports:l,imports:r};return packageJSONCache.set(e,p),p}function getPackageScopeConfig(e){let o=new URL("./package.json",e);for(;;){if(o.pathname.endsWith("node_modules/package.json"))break;const n=getPackageConfig(fileURLToPath(o),e);if(n.exists)return n;const t=o;if(o=new URL("../package.json",o),o.pathname===t.pathname)break}const n=fileURLToPath(o),t={pjsonPath:n,exists:!1,main:void 0,name:void 0,type:"none",exports:void 0,imports:void 0};return packageJSONCache.set(n,t),t}function defaultGetFormat(e,o,n){if(e.startsWith("node:"))return{format:"builtin"};const t=new URL(e);if("data:"===t.protocol){const[,e]=/^([^/]+\/[^;,]+)(?:[^,]*?)(;base64)?,/.exec(t.pathname)||[null,null,null];return{format:{__proto__:null,"text/javascript":"module","application/json":experimentalJsonModules?"json":null,"application/wasm":experimentalWasmModules?"wasm":null}[e]||null}}if("file:"===t.protocol){const o=extname(t.pathname);let n;if(n=".js"===o?"module"===getPackageScopeConfig(t.href).type?"module":"commonjs":extensionFormatMap[o],!n){if("node"!==experimentalSpeciferResolution)throw new Error(`Unknown Extension Type: ${o}, ${fileURLToPath(e)}`);process.emitWarning("The Node.js specifier resolution in ESM is experimental.","ExperimentalWarning"),n=legacyExtensionFormatMap[o]}return{format:n||null}}return{format:null}}export async function load(e,o,n){const t=(await getFormat(e,o,defaultGetFormat)).format;let r;if("builtin"!==t&&"commonjs"!==t){const o=getTracer();if(o&&o._esm){const n=o._esm;if(e===n.scratchFileUrl)return{format:t,source:n.scratchFileContent,shortCircuit:!0}}const{source:i}=await n(e,{format:t},n);if(null==i)throw new Error(`Failed to load raw source: Format was '${t}' and url was '${e}''.`);const a=(e,o,n)=>({source:e}),{source:s}=await transformSource(i,{url:e,format:t},a);r=s}else{const{source:o}=await n(e,{format:t},n);r=o}return{format:t,source:r}}export async function resolve(e,o,n){return resolveImplmentation(e,o,n)}