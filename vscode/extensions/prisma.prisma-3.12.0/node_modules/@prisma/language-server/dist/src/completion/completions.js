"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSuggestionsForInsideRoundBrackets = exports.getFieldTypesFromCurrentBlock = exports.getSuggestionForSupportedFields = exports.getValuesInsideSquareBrackets = exports.suggestEqualSymbol = exports.getSuggestionForBlockTypes = exports.getSuggestionForFirstInsideBlock = exports.getSuggestionsForFieldTypes = exports.getAllRelationNames = exports.getSuggestionForFieldAttribute = exports.getSuggestionForNativeTypes = exports.positionIsAfterFieldAndType = exports.getSymbolBeforePosition = exports.isInsideQuotationMark = exports.isInsideAttribute = exports.isInsideFieldArgument = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const completionUtil_1 = require("./completionUtil");
const klona_1 = require("klona");
const renameUtil_1 = require("../rename/renameUtil");
const previewFeatures_1 = __importDefault(require("../prisma-fmt/previewFeatures"));
const nativeTypes_1 = __importDefault(require("../prisma-fmt/nativeTypes"));
const util_1 = require("../util");
function toCompletionItems(allowedTypes, kind) {
    return allowedTypes.map((label) => ({ label, kind }));
}
function isInsideFieldArgument(currentLineUntrimmed, position) {
    const symbols = '()';
    let numberOfOpenBrackets = 0;
    let numberOfClosedBrackets = 0;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === symbols[0]) {
            numberOfOpenBrackets++;
        }
        else if (currentLineUntrimmed[i] === symbols[1]) {
            numberOfClosedBrackets++;
        }
    }
    return numberOfOpenBrackets >= 2 && numberOfOpenBrackets > numberOfClosedBrackets;
}
exports.isInsideFieldArgument = isInsideFieldArgument;
/***
 * @param symbols expects e.g. '()', '[]' or '""'
 */
function isInsideAttribute(currentLineUntrimmed, position, symbols) {
    let numberOfOpenBrackets = 0;
    let numberOfClosedBrackets = 0;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === symbols[0]) {
            numberOfOpenBrackets++;
        }
        else if (currentLineUntrimmed[i] === symbols[1]) {
            numberOfClosedBrackets++;
        }
    }
    return numberOfOpenBrackets > numberOfClosedBrackets;
}
exports.isInsideAttribute = isInsideAttribute;
/***
 * Checks if inside e.g. "here"
 * Does not check for escaped quotation marks.
 */
function isInsideQuotationMark(currentLineUntrimmed, position) {
    let insideQuotation = false;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === '"') {
            insideQuotation = !insideQuotation;
        }
    }
    return insideQuotation;
}
exports.isInsideQuotationMark = isInsideQuotationMark;
function getSymbolBeforePosition(document, position) {
    return document.getText({
        start: {
            line: position.line,
            character: position.character - 1,
        },
        end: { line: position.line, character: position.character },
    });
}
exports.getSymbolBeforePosition = getSymbolBeforePosition;
function positionIsAfterFieldAndType(position, document, wordsBeforePosition) {
    const symbolBeforePosition = getSymbolBeforePosition(document, position);
    const symbolBeforeIsWhiteSpace = symbolBeforePosition.search(/\s/);
    const hasAtRelation = wordsBeforePosition.length === 2 && symbolBeforePosition === '@';
    const hasWhiteSpaceBeforePosition = wordsBeforePosition.length === 2 && symbolBeforeIsWhiteSpace !== -1;
    return wordsBeforePosition.length > 2 || hasAtRelation || hasWhiteSpaceBeforePosition;
}
exports.positionIsAfterFieldAndType = positionIsAfterFieldAndType;
/**
 * Removes all block attribute suggestions that are invalid in this context.
 * E.g. `@@id()` when already used should not be in the suggestions.
 */
function removeInvalidAttributeSuggestions(supportedAttributes, block, lines) {
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        // TODO we should also remove the other suggestions if used (default()...)
        if (item.includes('@id')) {
            supportedAttributes = supportedAttributes.filter((attribute) => !attribute.label.includes('id'));
        }
    }
    return supportedAttributes;
}
function getSuggestionForModelBlockAttribute(block, lines) {
    if (block.type !== 'model') {
        return [];
    }
    // create deep copy
    const suggestions = removeInvalidAttributeSuggestions((0, klona_1.klona)(completionUtil_1.blockAttributes), block, lines);
    // We can filter on the datasource
    const datasourceProvider = getFirstDatasourceProvider(lines);
    // We can filter on the previewFeatures enabled
    const previewFeatures = getAllPreviewFeaturesFromGenerators(lines);
    // Full text indexes (MySQL and MongoDB)
    // https://www.prisma.io/docs/concepts/components/prisma-schema/indexes#full-text-indexes-mysql-and-mongodb
    const isFullTextAvailable = Boolean(datasourceProvider &&
        ['mysql', 'mongodb'].includes(datasourceProvider) &&
        (previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.includes('fulltextindex')));
    if (isFullTextAvailable === false) {
        // fullTextIndex is not available, we need to filter it out
        return suggestions.filter((arg) => arg.label !== '@@fulltext');
    }
    return suggestions;
}
function getSuggestionForNativeTypes(foundBlock, lines, wordsBeforePosition, document) {
    const activeFeatureFlag = declaredNativeTypes(document);
    if (
    // TODO type? native "@db." types?
    foundBlock.type !== 'model' ||
        !activeFeatureFlag ||
        wordsBeforePosition.length < 2) {
        return undefined;
    }
    const datasourceName = getFirstDatasourceName(lines);
    if (!datasourceName || wordsBeforePosition[wordsBeforePosition.length - 1] !== `@${datasourceName}`) {
        return undefined;
    }
    // line
    const prismaType = wordsBeforePosition[1].replace('?', '').replace('[]', '');
    const suggestions = getNativeTypes(document, prismaType);
    return {
        items: suggestions,
        isIncomplete: true,
    };
}
exports.getSuggestionForNativeTypes = getSuggestionForNativeTypes;
function getSuggestionForFieldAttribute(block, currentLine, lines, wordsBeforePosition, document) {
    // TODO type? suggestions for "@..." for type?
    if (block.type !== 'model') {
        return;
    }
    let suggestions = [];
    const enabledNativeTypes = declaredNativeTypes(document);
    // Because @.?
    if (enabledNativeTypes && wordsBeforePosition.length >= 2) {
        const datasourceName = getFirstDatasourceName(lines);
        const prismaType = wordsBeforePosition[1];
        const nativeTypeSuggestions = getNativeTypes(document, prismaType);
        if (datasourceName && nativeTypeSuggestions.length !== 0) {
            if (!currentLine.includes('@' + datasourceName)) {
                suggestions.push({
                    // https://code.visualstudio.com/docs/editor/intellisense#_types-of-completions
                    kind: vscode_languageserver_1.CompletionItemKind.Property,
                    label: '@' + datasourceName,
                    documentation: 'Defines a native database type that should be used for this field. See https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#native-types-mapping',
                    insertText: '@db.$0',
                    insertTextFormat: 2,
                });
            }
            else if (
            // Check that we are not separated by a space like `@db. |`
            wordsBeforePosition[wordsBeforePosition.length - 1] === `@${datasourceName}`) {
                suggestions.push(...nativeTypeSuggestions);
                return {
                    items: suggestions,
                    isIncomplete: false,
                };
            }
        }
        else {
            console.log('Did not receive any native type suggestions from prisma-fmt call.');
        }
    }
    suggestions.push(...completionUtil_1.fieldAttributes);
    if (!(currentLine.includes('Int') || currentLine.includes('String'))) {
        // id not allowed
        suggestions = suggestions.filter((sugg) => sugg.label !== '@id');
    }
    if (!currentLine.includes('DateTime')) {
        // updatedAt not allowed
        suggestions = suggestions.filter((sugg) => sugg.label !== '@updatedAt');
    }
    suggestions = removeInvalidAttributeSuggestions(suggestions, block, lines);
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForFieldAttribute = getSuggestionForFieldAttribute;
function getFirstDatasourceName(lines) {
    const datasourceBlockFirstLine = lines.find((l) => l.startsWith('datasource') && l.includes('{'));
    if (!datasourceBlockFirstLine) {
        return undefined;
    }
    const indexOfBracket = datasourceBlockFirstLine.indexOf('{');
    return datasourceBlockFirstLine.slice('datasource'.length, indexOfBracket).trim();
}
function getFirstDatasourceProvider(lines) {
    // matches provider inside datasource in any position
    // thanks to https://regex101.com for the online scratchpad
    const result = /datasource.*\{(\n|\N)\s*(.*\n)?\n*\s*provider\s=\s(\"(.*)\")[^}]+}/.exec(lines.join('\n'));
    if (!result || !result[4]) {
        return undefined;
    }
    const datasourceProvider = result[4];
    if (typeof datasourceProvider === 'string' && datasourceProvider.length >= 1) {
        return datasourceProvider;
    }
}
function getAllPreviewFeaturesFromGenerators(lines) {
    // matches any `previewFeatures = [x]` in any position
    // thanks to https://regex101.com for the online scratchpad
    const previewFeaturesRegex = /previewFeatures\s=\s(\[.*\])/g;
    // we could match against all the `previewFeatures = [x]` (could be that there is more than one?)
    // var matchAll = text.matchAll(regexp)
    // for (const match of matchAll) {
    //   console.log(match);
    // }
    const result = previewFeaturesRegex.exec(lines.join('\n'));
    if (!result || !result[1]) {
        return undefined;
    }
    try {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const previewFeatures = JSON.parse(result[1]);
        if (Array.isArray(previewFeatures) && previewFeatures.length > 0) {
            return previewFeatures.map((it) => it.toLowerCase());
        }
    }
    catch (e) { }
    return undefined;
}
function getAllRelationNames(lines) {
    const modelNames = [];
    for (const item of lines) {
        if (
        // TODO type?
        (item.includes('model') || item.includes('enum')) &&
            item.includes('{')) {
            // found a block
            const blockName = (0, renameUtil_1.extractModelName)(item);
            modelNames.push(blockName);
            // block is at least 2 lines long
        }
    }
    return modelNames;
}
exports.getAllRelationNames = getAllRelationNames;
function getSuggestionsForFieldTypes(foundBlock, lines, position, currentLineUntrimmed) {
    const suggestions = [];
    const datasourceProvider = getFirstDatasourceProvider(lines);
    // MongoDB doesn't support Decimal
    if (datasourceProvider === 'mongodb') {
        suggestions.push(...completionUtil_1.corePrimitiveTypes.filter((s) => s.label !== 'Decimal'));
    }
    else {
        suggestions.push(...completionUtil_1.corePrimitiveTypes);
    }
    if (foundBlock instanceof util_1.Block) {
        // get all model names
        const modelNames = getAllRelationNames(lines);
        suggestions.push(...toCompletionItems(modelNames, vscode_languageserver_1.CompletionItemKind.Reference));
    }
    const wordsBeforePosition = currentLineUntrimmed.slice(0, position.character).split(' ');
    const wordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 1];
    const completeSuggestions = suggestions.filter((s) => s.label.length === wordBeforePosition.length);
    if (completeSuggestions.length !== 0) {
        for (const sugg of completeSuggestions) {
            suggestions.push({
                label: `${sugg.label}?`,
                kind: sugg.kind,
                documentation: sugg.documentation,
            }, {
                label: `${sugg.label}[]`,
                kind: sugg.kind,
                documentation: sugg.documentation,
            });
        }
    }
    return {
        items: suggestions,
        isIncomplete: true,
    };
}
exports.getSuggestionsForFieldTypes = getSuggestionsForFieldTypes;
/**
 * Removes all field suggestion that are invalid in this context. E.g. fields that are used already in a block will not be suggested again.
 * This function removes all field suggestion that are invalid in a certain context. E.g. in a generator block `provider, output, platforms, pinnedPlatForm`
 * are possible fields. But those fields are only valid suggestions if they haven't been used in this block yet. So in case `provider` has already been used, only
 * `output, platforms, pinnedPlatform` will be suggested.
 */
function removeInvalidFieldSuggestions(supportedFields, block, lines, position) {
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine || key === position.line) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        const fieldName = item.replace(/ .*/, '');
        if (supportedFields.includes(fieldName)) {
            supportedFields = supportedFields.filter((field) => field !== fieldName);
        }
    }
    return supportedFields;
}
function getSuggestionForDataSourceField(block, lines, position) {
    // create deep copy
    const suggestions = (0, klona_1.klona)(completionUtil_1.supportedDataSourceFields);
    const labels = removeInvalidFieldSuggestions(suggestions.map((item) => item.label), block, lines, position);
    return suggestions.filter((item) => labels.includes(item.label));
}
function getSuggestionForGeneratorField(block, lines, position) {
    // create deep copy
    const suggestions = (0, klona_1.klona)(completionUtil_1.supportedGeneratorFields);
    const labels = removeInvalidFieldSuggestions(suggestions.map((item) => item.label), block, lines, position);
    return suggestions.filter((item) => labels.includes(item.label));
}
/**
 * gets suggestions for block type
 */
function getSuggestionForFirstInsideBlock(blockType, lines, position, block) {
    let suggestions = [];
    switch (blockType) {
        case 'datasource':
            suggestions = getSuggestionForDataSourceField(block, lines, position);
            break;
        case 'generator':
            suggestions = getSuggestionForGeneratorField(block, lines, position);
            break;
        case 'model':
            suggestions = getSuggestionForModelBlockAttribute(block, lines);
            break;
        case 'type':
            // No suggestions
            break;
    }
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForFirstInsideBlock = getSuggestionForFirstInsideBlock;
function getSuggestionForBlockTypes(lines) {
    // create deep copy
    const suggestions = (0, klona_1.klona)(completionUtil_1.allowedBlockTypes);
    // enum is not supported in sqlite
    let foundDataSourceBlock = false;
    for (const item of lines) {
        if (item.includes('datasource')) {
            foundDataSourceBlock = true;
            continue;
        }
        if (foundDataSourceBlock) {
            if (item.includes('}')) {
                break;
            }
            if (item.startsWith('provider') && item.includes('sqlite')) {
                suggestions.pop();
            }
        }
        if (!suggestions.map((sugg) => sugg.label).includes('enum')) {
            break;
        }
    }
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForBlockTypes = getSuggestionForBlockTypes;
function suggestEqualSymbol(blockType) {
    if (!(blockType == 'datasource' || blockType == 'generator')) {
        return;
    }
    const equalSymbol = { label: '=' };
    return {
        items: [equalSymbol],
        isIncomplete: false,
    };
}
exports.suggestEqualSymbol = suggestEqualSymbol;
function getValuesInsideSquareBrackets(line) {
    const regexp = /\[([^\]]+)\]/;
    const matches = regexp.exec(line);
    if (!matches || !matches[1]) {
        return [];
    }
    const result = matches[1].split(',');
    return result.map((v) => v.trim().replace('"', '').replace('"', ''));
}
exports.getValuesInsideSquareBrackets = getValuesInsideSquareBrackets;
function declaredNativeTypes(document) {
    const nativeTypes = (0, nativeTypes_1.default)(document.getText());
    if (nativeTypes.length === 0) {
        return false;
    }
    return true;
}
function handlePreviewFeatures(previewFeaturesArray, position, currentLineUntrimmed, isInsideQuotation) {
    let previewFeatures = previewFeaturesArray.map((pf) => vscode_languageserver_1.CompletionItem.create(pf));
    if (isInsideAttribute(currentLineUntrimmed, position, '[]')) {
        if (isInsideQuotation) {
            const usedValues = getValuesInsideSquareBrackets(currentLineUntrimmed);
            previewFeatures = previewFeatures.filter((t) => !usedValues.includes(t.label));
            return {
                items: previewFeatures,
                isIncomplete: true,
            };
        }
        else {
            return {
                items: completionUtil_1.previewFeaturesArguments.filter((arg) => !arg.label.includes('[')),
                isIncomplete: true,
            };
        }
    }
    else {
        return {
            items: completionUtil_1.previewFeaturesArguments.filter((arg) => !arg.label.includes('"')),
            isIncomplete: true,
        };
    }
}
function getNativeTypes(document, prismaType) {
    let nativeTypes = (0, nativeTypes_1.default)(document.getText());
    if (nativeTypes.length === 0) {
        return [];
    }
    const suggestions = [];
    nativeTypes = nativeTypes.filter((n) => n.prisma_types.includes(prismaType));
    nativeTypes.forEach((element) => {
        if (element._number_of_args + element._number_of_optional_args !== 0) {
            let documentation = '';
            if (element._number_of_optional_args !== 0) {
                documentation = `${documentation}Number of optional arguments: ${element._number_of_optional_args}.\n'`;
            }
            if (element._number_of_args !== 0) {
                documentation = `${documentation}Number of required arguments: ${element._number_of_args}.\n`;
            }
            suggestions.push({
                label: `${element.name}()`,
                kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
                insertText: `${element.name}($0)`,
                documentation: { kind: vscode_languageserver_1.MarkupKind.Markdown, value: documentation },
                insertTextFormat: 2,
            });
        }
        else {
            suggestions.push({
                label: element.name,
                kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
            });
        }
    });
    return suggestions;
}
// Suggest fields for a BlockType
function getSuggestionForSupportedFields(blockType, currentLine, currentLineUntrimmed, position, lines) {
    let suggestions = [];
    const isInsideQuotation = isInsideQuotationMark(currentLineUntrimmed, position);
    switch (blockType) {
        case 'generator':
            // provider
            if (currentLine.startsWith('provider')) {
                const providers = completionUtil_1.generatorProviders;
                if (isInsideQuotation) {
                    return {
                        items: providers,
                        isIncomplete: true,
                    };
                }
                else {
                    return {
                        items: completionUtil_1.generatorProviderArguments,
                        isIncomplete: true,
                    };
                }
            }
            // previewFeatures
            if (currentLine.startsWith('previewFeatures')) {
                const generatorPreviewFeatures = (0, previewFeatures_1.default)();
                if (generatorPreviewFeatures.length > 0) {
                    return handlePreviewFeatures(generatorPreviewFeatures, position, currentLineUntrimmed, isInsideQuotation);
                }
            }
            // engineType
            if (currentLine.startsWith('engineType')) {
                const engineTypesCompletion = completionUtil_1.engineTypes;
                if (isInsideQuotation) {
                    // We can filter on the previewFeatures enabled
                    const previewFeatures = getAllPreviewFeaturesFromGenerators(lines);
                    if (previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.includes('dataproxy')) {
                        return {
                            items: engineTypesCompletion,
                            isIncomplete: true,
                        };
                    }
                    else {
                        // filter out dataproxy engineType
                        return {
                            items: engineTypesCompletion.filter((arg) => arg.label !== 'dataproxy'),
                            isIncomplete: true,
                        };
                    }
                }
                else {
                    return {
                        items: completionUtil_1.engineTypeArguments,
                        isIncomplete: true,
                    };
                }
            }
            break;
        case 'datasource':
            // provider
            if (currentLine.startsWith('provider')) {
                let providers = (0, klona_1.klona)(completionUtil_1.dataSourceProviders);
                if (isInsideAttribute(currentLineUntrimmed, position, '[]')) {
                    // return providers that haven't been used yet
                    if (isInsideQuotation) {
                        const usedValues = getValuesInsideSquareBrackets(currentLineUntrimmed);
                        providers = providers.filter((t) => !usedValues.includes(t.label));
                        return {
                            items: providers,
                            isIncomplete: true,
                        };
                    }
                    else {
                        return {
                            items: completionUtil_1.dataSourceProviderArguments.filter((arg) => !arg.label.includes('[')),
                            isIncomplete: true,
                        };
                    }
                }
                else if (isInsideQuotation) {
                    return {
                        items: providers,
                        isIncomplete: true,
                    };
                }
                else {
                    return {
                        items: completionUtil_1.dataSourceProviderArguments,
                        isIncomplete: true,
                    };
                }
                // url
            }
            else if (currentLine.startsWith('url')) {
                // check if inside env
                if (isInsideAttribute(currentLineUntrimmed, position, '()')) {
                    suggestions = ['DATABASE_URL'];
                }
                else {
                    if (currentLine.includes('env')) {
                        return {
                            items: completionUtil_1.dataSourceUrlArguments.filter((a) => !a.label.includes('env')),
                            isIncomplete: true,
                        };
                    }
                    return {
                        items: completionUtil_1.dataSourceUrlArguments,
                        isIncomplete: true,
                    };
                }
            }
            break;
    }
    return {
        items: toCompletionItems(suggestions, vscode_languageserver_1.CompletionItemKind.Constant),
        isIncomplete: false,
    };
}
exports.getSuggestionForSupportedFields = getSuggestionForSupportedFields;
function getDefaultValues(currentLine, lines) {
    const suggestions = [];
    const datasourceProvider = getFirstDatasourceProvider(lines);
    // MongoDB only
    if (datasourceProvider === 'mongodb') {
        suggestions.push({
            label: 'auto()',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
            documentation: 'Represents default values that are automatically generated by the database.',
            insertText: 'auto()',
            insertTextFormat: 2,
        });
    }
    else {
        suggestions.push({
            label: 'dbgenerated("")',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
            documentation: 'The SQL definition of the default value which is generated by the database. This is not validated by Prisma.',
            insertText: 'dbgenerated("$0")',
            insertTextFormat: 2,
        });
    }
    const fieldType = getFieldType(currentLine);
    if (!fieldType) {
        return [];
    }
    switch (fieldType) {
        case 'Int':
            suggestions.push({
                label: 'autoincrement()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: 'Create a sequence of integers in the underlying database and assign the incremented values to the ID values of the created records based on the sequence.',
            });
            break;
        case 'DateTime':
            suggestions.push({
                label: 'now()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Set a timestamp of the time when a record is created.',
                },
            });
            break;
        case 'String':
            suggestions.push({
                label: 'uuid()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Generate a globally unique identifier based on the [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) spec.',
                },
            }, {
                label: 'cuid()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Generate a globally unique identifier based on the [cuid](https://github.com/ericelliott/cuid) spec.',
                },
            });
            break;
        case 'Boolean':
            suggestions.push({ label: 'true', kind: vscode_languageserver_1.CompletionItemKind.Value }, { label: 'false', kind: vscode_languageserver_1.CompletionItemKind.Value });
            break;
    }
    const modelOrEnum = (0, util_1.getModelOrTypeOrEnumBlock)(fieldType, lines);
    if (modelOrEnum && modelOrEnum.type === 'enum') {
        // get fields from enum block for suggestions
        const values = getFieldsFromCurrentBlock(lines, modelOrEnum);
        values.forEach((v) => suggestions.push({ label: v, kind: vscode_languageserver_1.CompletionItemKind.Value }));
    }
    return suggestions;
}
// checks if e.g. inside 'fields' or 'references' attribute
function isInsideGivenProperty(currentLineUntrimmed, wordsBeforePosition, attributeName, position) {
    if (!isInsideAttribute(currentLineUntrimmed, position, '[]')) {
        return false;
    }
    // We sort all attributes by their position
    const sortedAttributes = [
        {
            name: 'fields',
            position: wordsBeforePosition.findIndex((word) => word.includes('fields')),
        },
        {
            name: 'references',
            position: wordsBeforePosition.findIndex((word) => word.includes('references')),
        },
    ].sort((a, b) => (a.position < b.position ? 1 : -1));
    // If the last attribute (higher position)
    // is the one we are looking for we are in this attribute
    if (sortedAttributes[0].name === attributeName) {
        return true;
    }
    else {
        return false;
    }
}
function getFieldsFromCurrentBlock(lines, block, position) {
    const suggestions = [];
    let reachedStartLine = false;
    let field = '';
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        if (!item.startsWith('@@') && (!position || key !== position.line)) {
            field = item.replace(/ .*/, '');
            if (field !== '' && !field.startsWith('//')) {
                suggestions.push(field);
            }
        }
    }
    return suggestions;
}
function getFieldTypesFromCurrentBlock(lines, block, position) {
    const suggestions = new Map();
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        if (!item.startsWith('@@') && (!position || key !== position.line)) {
            const type = getFieldType(item);
            if (type !== undefined) {
                /* eslint-disable @typescript-eslint/no-unsafe-assignment */
                const existingSuggestion = suggestions.get(type);
                if (!existingSuggestion) {
                    suggestions.set(type, [key]);
                }
                else {
                    existingSuggestion.push(key);
                    suggestions.set(type, existingSuggestion);
                }
                /* eslint-enable @typescript-eslint/no-unsafe-assignment */
            }
        }
    }
    return suggestions;
}
exports.getFieldTypesFromCurrentBlock = getFieldTypesFromCurrentBlock;
function getFieldType(line) {
    const wordsInLine = line.split(/\s+/);
    if (wordsInLine.length < 2) {
        return undefined;
    }
    const type = wordsInLine[1];
    if (type.length !== 0) {
        return type;
    }
    return undefined;
}
function getSuggestionsForAttribute({ attribute, wordsBeforePosition, untrimmedCurrentLine, lines, block, position, }) {
    const firstWordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 1];
    const secondWordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 2];
    const wordBeforePosition = firstWordBeforePosition === ''
        ? secondWordBeforePosition
        : firstWordBeforePosition;
    let suggestions = [];
    // create deep copy with klona
    // We can filter on the datasource
    const datasourceProvider = getFirstDatasourceProvider(lines);
    // We can filter on the previewFeatures enabled
    const previewFeatures = getAllPreviewFeaturesFromGenerators(lines);
    if (attribute === '@relation') {
        if (datasourceProvider === 'mongodb') {
            suggestions = completionUtil_1.relationArguments.filter((arg) => arg.label !== 'map' && arg.label !== 'onDelete' && arg.label !== 'onUpdate');
        }
        else {
            suggestions = completionUtil_1.relationArguments;
        }
        // If we are right after @relation(
        if (wordBeforePosition.includes('@relation')) {
            return {
                items: suggestions,
                isIncomplete: false,
            };
        }
        if (isInsideGivenProperty(untrimmedCurrentLine, wordsBeforePosition, 'fields', position)) {
            return {
                items: toCompletionItems(getFieldsFromCurrentBlock(lines, block, position), vscode_languageserver_1.CompletionItemKind.Field),
                isIncomplete: false,
            };
        }
        if (isInsideGivenProperty(untrimmedCurrentLine, wordsBeforePosition, 'references', position)) {
            // Get the name by potentially removing ? and [] from Foo? or Foo[]
            const referencedModelName = wordsBeforePosition[1]
                .replace('?', '')
                .replace('[]', '');
            const referencedBlock = (0, util_1.getModelOrTypeOrEnumBlock)(referencedModelName, lines);
            // referenced model does not exist
            // TODO type?
            if (!referencedBlock || referencedBlock.type !== 'model') {
                return;
            }
            return {
                items: toCompletionItems(getFieldsFromCurrentBlock(lines, referencedBlock), vscode_languageserver_1.CompletionItemKind.Field),
                isIncomplete: false,
            };
        }
    }
    else {
        // @id, @unique
        // @@id, @@unique, @@index, @@fulltext
        // The length argument is available on MySQL only on the
        // @id, @@id, @unique, @@unique and @@index fields.
        // The sort argument is available for all databases on the
        // @unique, @@unique and @@index fields.
        // Additionally, SQL Server also allows it on @id and @@id.
        if (isInsideAttribute(untrimmedCurrentLine, position, '[]')) {
            // extendedIndexes
            if ((previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.includes('extendedindexes')) && isInsideFieldArgument(untrimmedCurrentLine, position)) {
                let attribute = undefined;
                if (wordsBeforePosition.some((a) => a.includes('@@id'))) {
                    attribute = '@@id';
                }
                else if (wordsBeforePosition.some((a) => a.includes('@id'))) {
                    attribute = '@id';
                }
                else if (wordsBeforePosition.some((a) => a.includes('@@unique'))) {
                    attribute = '@@unique';
                }
                else if (wordsBeforePosition.some((a) => a.includes('@unique'))) {
                    attribute = '@unique';
                }
                else if (wordsBeforePosition.some((a) => a.includes('@@index'))) {
                    attribute = '@@index';
                }
                if (attribute) {
                    return {
                        items: (0, completionUtil_1.filterSortLengthBasedOnInput)(attribute, previewFeatures, datasourceProvider, wordBeforePosition, completionUtil_1.sortLengthProperties),
                        isIncomplete: false,
                    };
                }
            }
            let items = getFieldsFromCurrentBlock(lines, block, position);
            // get parameters inside block attribute
            const parameterMatch = new RegExp(/(?<=\[).+?(?=\])/).exec(untrimmedCurrentLine);
            if (parameterMatch) {
                const existingParameters = parameterMatch[0].split(',').map((param) => param.trim());
                items = items.filter((s) => !existingParameters.includes(s));
            }
            return {
                items: toCompletionItems(items, vscode_languageserver_1.CompletionItemKind.Field),
                isIncomplete: false,
            };
        }
        // "@@" block attributes
        let blockAtrributeArguments = [];
        if (wordsBeforePosition.some((a) => a.includes('@@unique'))) {
            blockAtrributeArguments = (0, completionUtil_1.givenBlockAttributeParams)('@@unique');
        }
        else if (wordsBeforePosition.some((a) => a.includes('@@id'))) {
            blockAtrributeArguments = (0, completionUtil_1.givenBlockAttributeParams)('@@id');
        }
        else if (wordsBeforePosition.some((a) => a.includes('@@index'))) {
            // Auto completion for Hash and BTree for PostgreSQL
            // includes because `@@index(type: |)` means wordBeforePosition = '@@index(type:'
            // TODO figure out if we need to add cockroachdb provider here
            if (datasourceProvider &&
                ['postgresql', 'postgres'].includes(datasourceProvider) &&
                wordBeforePosition.includes('type:')) {
                // TODO move away
                const indexTypeCompletionItems = [
                    {
                        label: 'Hash',
                        kind: 13,
                        insertTextFormat: 1,
                        documentation: {
                            kind: 'markdown',
                            value: 'The Hash index can perform a faster lookup than a B-Tree index. However, the key downside of the Hash index is that its use is limited to equality operators that will perform matching operations.',
                        },
                    },
                    {
                        label: 'BTree',
                        kind: 13,
                        insertTextFormat: 1,
                        documentation: {
                            kind: 'markdown',
                            value: "The B-tree index is the default, it creates a self-balanced tree, in other words, it sorts itself. It will maintain its balance throughout operations such as insertions, deletions and searches. Using a B-tree index speeds up scan operations because it doesn't have to scan pages or records sequentially in a linear fashion.",
                        },
                    },
                ];
                return {
                    items: indexTypeCompletionItems,
                    isIncomplete: false,
                };
            }
            blockAtrributeArguments = (0, completionUtil_1.givenBlockAttributeParams)('@@index', previewFeatures, datasourceProvider);
        }
        else if (wordsBeforePosition.some((a) => a.includes('@@fulltext'))) {
            blockAtrributeArguments = (0, completionUtil_1.givenBlockAttributeParams)('@@fulltext');
        }
        if (blockAtrributeArguments.length) {
            suggestions = blockAtrributeArguments;
        }
        else {
            // "@" field attributes
            let fieldAtrributeArguments = [];
            if (wordsBeforePosition.some((a) => a.includes('@unique'))) {
                fieldAtrributeArguments = (0, completionUtil_1.givenFieldAttributeParams)('@unique', previewFeatures, datasourceProvider, wordBeforePosition);
            }
            else if (wordsBeforePosition.some((a) => a.includes('@id'))) {
                fieldAtrributeArguments = (0, completionUtil_1.givenFieldAttributeParams)('@id', previewFeatures, datasourceProvider, wordBeforePosition);
            }
            else if (wordsBeforePosition.some((a) => a.includes('@@index'))) {
                fieldAtrributeArguments = (0, completionUtil_1.givenFieldAttributeParams)('@@index', previewFeatures, datasourceProvider, wordBeforePosition);
            }
            suggestions = fieldAtrributeArguments;
        }
    }
    // Check which attributes are already present
    // so we can filter them out from the suggestions
    const attributesFound = new Set();
    for (const word of wordsBeforePosition) {
        if (word.includes('references')) {
            attributesFound.add('references');
        }
        if (word.includes('fields')) {
            attributesFound.add('fields');
        }
        if (word.includes('onUpdate')) {
            attributesFound.add('onUpdate');
        }
        if (word.includes('onDelete')) {
            attributesFound.add('onDelete');
        }
        if (word.includes('map')) {
            attributesFound.add('map');
        }
        if (word.includes('name') || /".*"/.exec(word)) {
            attributesFound.add('name');
            attributesFound.add('""');
        }
        if (word.includes('type')) {
            attributesFound.add('type');
        }
    }
    // now filter them out of the suggestions as they are already present
    const filteredSuggestions = suggestions.reduce((accumulator, sugg) => {
        let suggestionMatch = false;
        for (const attribute of attributesFound) {
            if (sugg.label.includes(attribute)) {
                suggestionMatch = true;
            }
        }
        if (!suggestionMatch) {
            accumulator.push(sugg);
        }
        return accumulator;
    }, []);
    // nothing to present any more, return
    if (filteredSuggestions.length === 0) {
        return;
    }
    return {
        items: filteredSuggestions,
        isIncomplete: false,
    };
}
function getSuggestionsForInsideRoundBrackets(untrimmedCurrentLine, lines, document, position, block) {
    const wordsBeforePosition = untrimmedCurrentLine.slice(0, position.character).trimLeft().split(/\s+/);
    const wordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 1];
    if (wordBeforePosition.includes('@default')) {
        return {
            items: getDefaultValues(lines[position.line], lines),
            isIncomplete: false,
        };
    }
    else if (wordsBeforePosition.some((a) => a.includes('@relation'))) {
        return getSuggestionsForAttribute({
            attribute: '@relation',
            wordsBeforePosition,
            untrimmedCurrentLine,
            lines,
            // document,
            block,
            position,
        });
    }
    else if (
    // matches
    // @id, @unique
    // @@id, @@unique, @@index, @@fulltext
    wordsBeforePosition.some((a) => a.includes('@unique') || a.includes('@id') || a.includes('@@index') || a.includes('@@fulltext'))) {
        return getSuggestionsForAttribute({
            wordsBeforePosition,
            untrimmedCurrentLine,
            lines,
            // document,
            block,
            position,
        });
    }
    else {
        return {
            items: toCompletionItems([], vscode_languageserver_1.CompletionItemKind.Field),
            isIncomplete: false,
        };
    }
}
exports.getSuggestionsForInsideRoundBrackets = getSuggestionsForInsideRoundBrackets;
//# sourceMappingURL=completions.js.map